Summary,Document
"In both cases, a ""signature"" is just a proof the author possessed a particular key, and applied it to a specific message body.","It's actually the same concept... in both cases the ""signature"" is a short number of bytes generated based on the message and some secret key, which can be regenerated to prove the author possessed the key and the message... i.e., that they ""signed"" it.  The main difference lies in how the signature is verified. For MACs, it's generally based on a shared private key, so the recipient would also have to have the secret key, which they'd use to regenerate the MAC signature.  For public-key systems, the signer generally digests the message (via sha256, etc) and then encrypts the digest with their private key... the verification process therefore requires decrypting using the public key, and verifying the resulting digest. Only someone who has the private key should be able to encrypt the digest correctly, thus proving they had the private key to ""sign"" the message.  tl;dr  In both cases, a ""signature"" is just a proof the author possessed a particular key, and applied it to a specific message body. "
writing your own special purpose CSV parser is often by far the best course of action..,"I think the author is missing a couple of elephant-size details though.  In many (most?) real-world usages of CSV, the consumer does NOT care about any of those special cases (or deals with one or two) and then writing your own is often much simpler than bringing in an external dependency.  And,  chances are very non-trivial, that the quirk you have to handle will be rare enough that your external library will choke on it.  And, in many cases you might want to parse that CSV into  meaningful (app specific) data structures rather than plain arrays, and then this external dependency will provide very litte value..   TLDR, writing your own special purpose CSV parser is often by far the best course of action.. "
build time complaints are more due to incompetence of users than anything else.,"While C compiles slowly and C++ even slower, I bet that people who complain about build times either structure their code  really badly  (e.g. all in one massive executable; why?!), either do not know how to utilise the tooling to speed builds up (e.g. precompiled headers, incremental linking, taking care of gratuitous compile time dependencies)  edit: they probably do both .  Also, when working on a big code, one  never  builds everything. Rather, one builds a dozen of files they are working on at the time and, their dependencies in test code and test code itself.  Disclaimer: I work on some 8000 files codebase.  tl;dr: build time complaints are more due to incompetence of users than anything else. "
I thought the original post was silly until I read your comment,"When I read the original post I laughed: ""Haha! Silly journalists! They don't understand that the cars computer system just tells the door locks to activate when the accelerator is pressed, it doesn't mean you could control the accelerator from the locks, the system is way to simple to be used like that! It's the equivalent of suggesting that because an interlock stops a microwave operating with the door open, you could hack the microwave to 'lock' the door closed""  After reading your comment my initial thought was: ""What!? Cars have become this complex? The gas pedal is connected to the engine via a computer network that has bridges and routing rules to prevent inappropriate control of the throttle?! It's not just a simple connection!?""  tl;dr: I thought the original post was silly until I read your comment "
Customer fixed a performance problem by looking at the end of a fiber optic cable.,"Very similar to what I do on a daily basis, except for I'm debugging our own server software. Recently closed a case where the customer was experiencing some 60 second hangs, multiple times per day. Using similar debugging techniques I was able to narrow down the exact times when it was happening. This particular case didn't require a windbg dump since I was able to find that each one of the hangs ended with a timeout to the WriteFile function (using some internal counters in the server software). Told the customer that it looked like a communication problem with the SAN. Customer comes back a few hours later saying that he noticed that the transmit power was low, so he pulled the fiber cable (redundant) and couldn't see any light coming out. So he replaced the cable and boom that fixed the write timeouts.  TL;DR - Customer fixed a performance problem by looking at the end of a fiber optic cable. "
contact me if you are interested in a project that involves the title.,"I am about to work on a WordPress project that requires a visual representation of donations received. There will be multiple projects seeking donations on this site simultaneously and each requires its own progress bar.  Example: Project 1 has a goal of $5,000, project 2 a goal of $20,000, and project 3 a goal of $50,000. If project 1 has raised $2,500, the progress bar needs to show 50% of the goal has been achieved, project 2 $15,000 of $20,000 progress bar needs to show 75%, and so on. Essentially, I need what Kickstarter displays for all the various projects receiving donations.  As stated previously, it needs to integrate with WordPress. It also needs to integrate with PayPal.  Is this best accomplished in JavaScript given the parameters outlined above? If not JavaScript, other suggestions? How long would something like this take for someone familiar/skilled in the programming language? What would something like this cost?  tl;dr  contact me if you are interested in a project that involves the title. "
'Node isn't designed for X' is a bad response to the criticism 'Node is bad because it isn't designed for X'.,"Your analogy essentially boiled down to 'don't complain that tools don't work well when you use them for things they weren't designed to be used for', is that a fair assessment?  My analogy was that your comparison wasn't really fair. Defending node by saying it wasn't designed for CPU-bound work would be reasonable if you couldn't have a framework or library or language designed for both CPU-bound and IO-bound work, but you can. They exist, they're plentiful. So the argument that criticising Node for being bad for CPU-bound tasks is unfair because it's designed for IO-bound tasks misses the point that there's no reason that Node couldn't be good for CPU-bound tasks, given that lots of other similar projects/libraries/frameworks/languages do fine at both.  Your entire argument boils down to a false dichotomy, the ridiculous idea that in order to provide good performance for IO-bound tasks you need to sacrifice performance for CPU-bound tasks.  TL;DR: 'Node isn't designed for X' is a bad response to the criticism 'Node is bad because it isn't designed for X'. "
Is it possible to debug in VS Code using this Rust plugin  with or without another helper plugin    If so  then I like it.,"I'm not sure if this is the same one -- but in the past, I used a Rust plugin for VS Code along with an lldb plugin (I needed to have both for the best experience).. and the combination provided support for runtime debugging (breakpoints, watch window, etc.).  It worked fine, but it was a little tricky to setup as they were two separate plugins and neither was very mature.  In contrast, IntelliJ IDEA's Rust plugin(s) does not have debugging support, and it is very unlikely that it will ever have it since the underlying native debugging support (gdb and/or lldb) is only intended to ship with CLion (not IDEA).  For me, any Rust IDE that doesn't have a debugger is a total non-starter.  tl;dr: Is it possible to debug in VS Code using this Rust plugin (with or without another helper plugin)?  If so, then I like it. "
candidates with open source have an advantage because there is more time to technically review them outside of the interview and more examples to look at.,"I work at a large Silicon Valley household-name company and interview candidates regularly.  Candidates who have a lot of recent Open Source work have an advantage over those that don't because I can talk with them about their projects, which they're generally more at home with and excited about.  I also have hours or even days to review their code online, so I get a strong idea of where their skill set is.  Candidates without recent open source work I have to grill a bit more to get an idea of where they are technically. Even then, my time with them is limited to an hour or so. Where the other candidates has gotten hours of my time.  People with open source experience also look like more passionate contributors than their open-sourceless counterparts. Right or wrong, this is the impression that it gives.  TL;DR: candidates with open source have an advantage because there is more time to technically review them outside of the interview and more examples to look at. "
I need help translating the Japanese menus on this .Net/C++ application!,"I've recently acquired a Blackmagic Intensity Pro HD capture card to record some gaming on my Xbox 360 & PS3 and it just so happens that there is a great, lightweight program that is much better than the one that came with the card designed for doing exactly what I am doing. The only problem is that it is in Japanese, I've gotten a ways using  Resource Hacker but I don't speak Japanese and some of the items cannot be changed in Resource Hacker, specifically the submenu that changes while your recording. If reddit could point me in the direction of a tutorial or give me a hand with the translation that would be great! I've put a link to the page for the program below.  TL;DR  I need help translating the Japanese menus on this .Net/C++ application! "
each one teach one and we all get smarterer (sic),"in the martial arts, part of the work involved in achieving higher belts is teaching the lower belts. so it is for computer programming. teaching what you have learned solidifies your foundation on which you can learn more.  as for stackoverflow, i was unaware that gameification was the attraction. i thought it was just an easy platform to share answers, and we computer geeks tend to like to share, especially those of us that have the appropriate level of humility that reminds us that no matter how frequently we are the smartest person in the room, that has more to do with the room than with us.  so screw game points, i'm a grown man. i will gladly teach what i know, because i want to learn  tl;dr  each one teach one and we all get smarterer (sic) "
My naive questions as a junior engineer may have changed an aerospace standard.,"It's been a long time since I've been in that world, so I don't know what current state of the art is. In my day, it was all manual, and for hardware, component by component.  Interesting anecdote: I was working on a complex timer module, which used crystal oscillators. The vendor I used asked me what kind of fill gas I wanted. Knowing nothing about crystals,  I asked about options, he explained the various typical fill gasses, dry nitrogen, helium, etc. I asked what would happen if the seal failed in a vacuum. He told me the frequency would shift significantly. I reasoned that a slow leak might never be noticed at ambient (diffusing very slowly with ambient air). I asked him if they could make crystals with evacuated enclosures. He said they could. I reasoned that with those, a leak at ground level would show up quickly, and in orbit would be benign. I spec'ed evacuated enclosure crystals for the module and explained my reasoning to the prime contractor. They thought it was such a good idea that they might make it the spec system wide.  TL;DR My naive questions as a junior engineer may have changed an aerospace standard. "
"The article is about the mathematical method, and not the task of swapping variables.","I think some people are missing the point about this article, and jumping straight on the ""Don't do this ever, compilers are smarter than you"" bandwagon.  Firstly, it's an article about how to apply group theory to prove a given binary operator is suitable for your task. Using it to swap variables is one example, but you could apply it to some other two-variable task such as calculating the distance from a point, or some cryptographic hash function.  Secondly, if you are taking the article at face value, it is easy to conceive of a system that is limited in memory, registers or has a dodgy compiler where this trick is useful. If you've ever had to write a compiler for a school project on a test-bed cpu, then you'll know.  On most common machines, swapping variables like this is impractical, but it's important to know that things like this exist, and how to prove they're correct.  TL;DR: The article is about the mathematical method, and not the task of swapping variables. "
The GIL doesn't work like you think. Profile or GTFO. Scale horizontally.,"Dropping the GIL has been done a few times before and never has resulted in any non-niche performance increase.  This is because the GIL is not held for anywhere between 50% to 99% of the time depending on what your application does.  I have yet to find anyone who has told me ""the GIL made my application suck"" that actually profiled their app and interpreter.  If you actually do find yourself in a situation where you need to scale, it's usually better to scale horizontally with modules like ""multiprocess"".  Vertical scaling just has too low of a ceiling anyway.  The cases where someone actually needs HPC-style threading behavior are vanishingly rare outside of science (see also, numpy and umpteen other C extensions that don't hold the GIL).  tl;dr The GIL doesn't work like you think. Profile or GTFO. Scale horizontally. "
The tech was sacked for not keeping Windows up to date and I got twice as many hand cramps for a month or so.,"Whilst not an old DOS virus, I remember Sasser taking down my schools network in 2004, it infected the domain controller servers that the school used and then jumped to the XP machines that I and every kid, teacher and staff member were using.  It was a nasty little bastard, the teachers talked to the techs and only after a few weeks did it finally get mentioned that the computers (Both clients and servers) weren't really up to date (So Blaster was probably on there too).  It caused the network to go down and take all IT classes with it, which didn't bother anyone except me, who to this day has a seething hatred for writing with a pen due to the hand cramps I still get.  At first, I laughed my arse off at the computers going down thinking Sasser was an awesome worm, it decided to put me on the list of shit to fuck up that day because now I had to write. Â¬_Â¬  TL;DR The tech was sacked for not keeping Windows up to date and I got twice as many hand cramps for a month or so. "
I like having a bootcamp grad on my team because they can relate to programmers and non programmers.,"A lot of people disagree with me on this, but this is part of why I am partial to considering Bootcamp grads, especially if they had real careers before learning basic web-dev.  What they lack in dev skills can sometimes be made up for in empathy and understanding the mindset of non-programmers. You ever talked to anyone who just randomly started a codeacademy course? They'll say things like ""I don't really see why having arrays and looping through them are important."" Whereas for us, this is fundamental to almost everything we do. We clearly see the world differently.  These bootcamp grads can relate to both worlds. They didn't know what an array was a year ago. In my experience, explaining these concepts often can be a source of miscommunication and friction. They can give really good feedback about whether I am explaining something in a way that makes sense to non-developers.  TLDR: I like having a bootcamp grad on my team because they can relate to programmers and non-programmers. "
"If you want to program in Java, then program in Java.","Opening a file is not a feature of the C language. Neither are finding out the length of an opened file, heap allocation of a buffer of that size, file I/O, or closing of a file. Rather, these are library functions with defined behaviour in failure circumstances.  Why you would want a function to do something besides return an error code is beyond me. libpng handles errors with a longjmp(3) to a specified  jmp_buf , and because of the extra  volatile s that approach is no better than libjpeg's return value idiom in terms of being tricky; on the contrary it is worse since the programmer is used to reading  if(n != 0) goto fail; , expecting an absence of such only in the case of functions that don't have a failure condition that breaks the program's subsequent operation.  tl;dr: If you want to program in Java, then program in Java. "
it is one of the most important concepts in software engineering and the best way of organizing software functionality.,"A user story is a discrete task a user should be able to do with the software. A user story might be ""I want to be able to add a customer into the system."" From starting out understanding what the customer wants from the software, you can then add tasks to this user story in order to make this happen. Tasks might be ""create webpage/create customer table/create add customer query."" User stories usually have ""story points"" that are fibonacci's sequences numbers. So you might assign 1, 2, or 3 points to the easy user stories, 5 to moderate user stories and 8 or 13 to complex user stories. Tasks are usually given hours of estimation.  tl;dr it is one of the most important concepts in software engineering and the best way of organizing software functionality. "
"browser detection used to be taboo, nowadays, it's not that bad. Just make sure you're aware of and accept the downsides of using it.","Detecting browsers is useful if, like Google, you're only supporting recent versions of browsers. I no longer support IE9 or Safari 5 on my sites. I  could  use feature detection to warn my users, but considering that my sites are  guaranteed  to break in those browsers, why try to detect all 20 features when it's easier to just warn if their browser is old?  Usually, I get the response of ""what if they're using an obscure browser?"". In that case, browser detection doesn't work. But considering how few of my sites users will be using an obscure browser, and the chance of somebody using one already knowing the pitfalls of using it, I don't really care.  TL;DR: browser detection used to be taboo, nowadays, it's not that bad. Just make sure you're aware of and accept the downsides of using it. "
"If you are a kernel developer, don't use typedefs. All other folks continue enjoying coding however they like.","To sum it up: typedefs can be a good thing for an application or for library code (although the latter case sometimes leads to a lot of casts if my code doesn't use the exact same types the library uses), but for a kernel that is developed in C by thousands of developers, they are a bad choice.  The reason Linus gives is that they make coding more implicit (in the sense of higher level), while kernel-level programming is inherently low-level, and thus should be explicit. This mismatch is causing a lot of trouble to thousands of other developers, which is why Linus asks kernel developers not to use typedefs.  TL;DR: If you are a kernel developer, don't use typedefs. All other folks continue enjoying coding however they like. "
